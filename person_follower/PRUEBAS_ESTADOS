import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
import math

class PersonFollower(Node):
    def __init__(self):
        super().__init__('person_follower')
        self.publisher_ = self.create_publisher(Twist, '/cmd_vel', 10)
        self.subscription = self.create_subscription(
            LaserScan,
            '/scan',
            self.listener_callback,
            10)
        self.state = "reposo"  # Estado inicial
        self.prev_ranges = []  # Store previous laser readings
        self.prev_angles = []  # Store previous angles for smoothing
        self.min_distance = 0.4  # Set a minimum distance to avoid collisions
        self.angle_filter_window = 5  # Window size for angle smoothing
        self.search_threshold = 1.5  # Rango de detección durante la búsqueda
        self.follow_threshold = 0.25  # Rango de detección durante el seguimiento
        self.follow_angle_range = 75  # Rango de ángulo de detección durante el seguimiento
        self.follow_angle_start = -self.follow_angle_range / 2  # Ángulo inicial del rango de detección
        self.follow_angle_end = self.follow_angle_range / 2  # Ángulo final del rango de detección

    def detect_person(self, ranges, angle_min, angle_increment):
        # Lógica para detectar a una persona
        start_index = max(0, int((self.follow_angle_start - angle_min) / angle_increment))
        end_index = min(len(ranges) - 1, int((self.follow_angle_end - angle_min) / angle_increment))
        relevant_ranges = ranges[start_index:end_index+1]
        min_range = min(relevant_ranges)
        return min_range < self.follow_threshold

    def smooth_angle(self, angle):
        # Lógica para suavizar el ángulo
        self.prev_angles.append(angle)
        if len(self.prev_angles) > self.angle_filter_window:
            self.prev_angles.pop(0)
        return sum(self.prev_angles) / len(self.prev_angles)

    def change_state(self, new_state):
        # Cambiar el estado del robot
        self.state = new_state

    def listener_callback(self, input_msg):
        angle_min = input_msg.angle_min
        angle_max = input_msg.angle_max
        angle_increment = input_msg.angle_increment
        ranges = input_msg.ranges

        if self.state == "reposo":
            # En estado de reposo, no hacer nada
            return

        if self.state == "busqueda":
            # Realizar una búsqueda de 360 grados
            if self.detect_person(ranges, angle_min, angle_increment):
                # Si se detecta a una persona, cambiar al estado de seguimiento
                self.change_state("seguimiento")
            else:
                # Realizar una búsqueda completa girando en el lugar
                output_msg = Twist()
                output_msg.angular.z = 0.5  # Velocidad angular para girar
                self.publisher_.publish(output_msg)
            return

        if self.state == "seguimiento":
            # Estado de seguimiento: seguir a la persona detectada
            if self.detect_person(ranges, angle_min, angle_increment):
                min_range_index = ranges.index(min(ranges))
                angle_to_person = angle_min + min_range_index * angle_increment
                if self.prev_angles:
                    angle_to_person = self.smooth_angle(angle_to_person)

                if min(ranges) < self.min_distance:
                    vx = 0.05  # Velocidad reducida
                else:
                    vx = 0.35  # Velocidad normal

                target_angle = angle_to_person
                angle_difference = -target_angle  # Cambio de orientación para moverse

                max_angular_velocity = 0.6
                if abs(angle_difference) > max_angular_velocity:
                    angle_difference = max_angular_velocity if angle_difference > 0 else -max_angular_velocity

                wz = 2.0 * angle_difference

                output_msg = Twist()
                output_msg.linear.x = vx
                output_msg.angular.z = wz
                self.publisher_.publish(output_msg)
            else:
                # Si la persona ya no se detecta, volver al estado de búsqueda
                self.change_state("busqueda")
            return

def main(args=None):
    rclpy.init(args=args)
    person_follower = PersonFollower()

    # Cambiar al estado de reposo inicialmente
    person_follower.change_state("reposo")

    # Después de un tiempo, cambiar al estado de búsqueda
    person_follower.get_logger().info("Iniciando búsqueda...")
    person_follower.change_state("busqueda")

    rclpy.spin(person_follower)
    person_follower.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
